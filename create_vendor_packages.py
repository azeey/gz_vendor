import argparse
import sys
from catkin_pkg.package import Dependency, parse_package_string, Package
import re
import copy
import jinja2

VENDOR_PKG_XML_TEMPLATE = '''\
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<!-- This file is automatically generated. Do not modify! -->
<package format="3">
  <name>{{ vendor_name }}</name>
  <version>{{ pkg.version }}</version>
  <description>{{ pkg.description }}</description>
  {% for maintainer in pkg.maintainers %}
  <maintainer email="{{ maintainer.email }}">{{ maintainer.name }}</maintainer>
  {% endfor %}
  {% for license in pkg.licenses %}
  <license>{{ license }}</license>
  {% endfor %}
  {% for url in pkg.urls %}
  <url type="{{ url.type }}">{{ url.url }}</url>
  {% endfor %}
  {% for author in pkg.authors %}
  <author email="{{ author.email }}">{{ author.name }}</author>
  {% endfor %}

  <buildtool_depend>ament_cmake_core</buildtool_depend>
  <buildtool_depend>ament_cmake_test</buildtool_depend>
  <buildtool_depend>ament_cmake_vendor_package</buildtool_depend>

  {% for dep in pkg.build_depends %}
  <build_depend>{{ dep.name }}</build_depend>
  {% endfor %}
  {% for dep in pkg.exec_depends %}
  <exec_depend>{{ dep.name }}</exec_depend>
  {% endfor %}
  {% for dep in pkg.test_depends %}
  <test_depend>{{ dep.name }}</test_depend>
  {% endfor %}
  {% for dep in pkg.doc_depends %}
  <doc_depend>{{ dep.name }}</doc_depend>
  {% endfor %}
  {% for dep in gz_vendor_deps %}
  <depend>{{ dep.name }}</depend>
  {% endfor %}

  <!-- Depend on the package we are vendoring to allow building it from source -->
  <build_depend condition="$GZ_BUILD_FROM_SOURCE != ''">{{ pkg.name }}</build_depend>

  <test_depend>ament_cmake_copyright</test_depend>
  <test_depend>ament_cmake_lint_cmake</test_depend>
  <test_depend>ament_cmake_xmllint</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>

'''

CMAKES_TEMPLATE = '''\
# This file is automatically generated. Do not modify!
cmake_minimum_required(VERSION 3.10)
project({{ vendor_name }})

# Project-specific settings
set(LIB_DESIGNATOR {{ lib_designator }})
set(LIB_VER_MAJOR {{ version.major }})
set(LIB_VER_MINOR {{ version.minor }})
set(LIB_VER_PATCH {{ version.patch }})

# Derived variables
set(LIB_NAME gz-${LIB_DESIGNATOR})
set(LIB_NAME_FULL ${LIB_NAME}${LIB_VER_MAJOR})
set(LIB_VER ${LIB_VER_MAJOR}.${LIB_VER_MINOR}.${LIB_VER_PATCH})

find_package(ament_cmake_core REQUIRED)
find_package(ament_cmake_vendor_package REQUIRED)
find_package(ament_cmake_export_dependencies REQUIRED)

{% for dep in gz_vendor_deps %}
find_package({{ dep }} REQUIRED)
{% endfor %}

# Set the VERSION_MATCH to "EXACT" by default, but relax the requirement
# if we are users are building from source (determined by the
# GZ_BUILD_FROM_SOURCE environment variable) or if explicitly told to do so
# by the GZ_RELAX_VERSION_MATCH environment variable.
set(VERSION_MATCH "EXACT")
if(NOT $ENV{GZ_BUILD_FROM_SOURCE} STREQUAL "")
  set(VERSION_MATCH "")
endif()

if(NOT $ENV{GZ_RELAX_VERSION_MATCH} STREQUAL "")
  set(VERSION_MATCH "")
endif()

find_package(${LIB_NAME_FULL} ${VERSION_MATCH} ${LIB_VER} COMPONENTS all QUIET)
ament_vendor(gz_${LIB_DESIGNATOR}_vendor
  SATISFIED ${${LIB_NAME_FULL}_FOUND}
  VCS_URL https://github.com/gazebosim/${LIB_NAME}.git
  VCS_VERSION ${LIB_NAME_FULL}_${LIB_VER}
  CMAKE_ARGS
    -DBUILD_DOCS:BOOL=OFF
)

find_package(ament_cmake_test REQUIRED)
if(BUILD_TESTING)
  find_package(ament_cmake_lint_cmake REQUIRED)
  find_package(ament_cmake_copyright REQUIRED)
  find_package(ament_cmake_xmllint REQUIRED)

  ament_lint_cmake()
  ament_copyright()
  ament_xmllint()
endif()

ament_export_dependencies(
{% for dep in gz_vendor_deps %}
  {{ dep }}
{% endfor %}
)
ament_package(
  CONFIG_EXTRAS_POST "{{ vendor_name }}-extras.cmake.in"
)

'''

GZ_LIBRARIES = [
    'gz-cmake',
    'gz-tools',
    'gz-utils',
    'gz-math',
    'gz-common',
    'gz-plugin'
    'gz-msgs'
    'gz-transport',
    'gz-physics',
    'gz-rendering',
    'gz-sensors',
    'gz-gui',
    'gz-sim',
    'gz-launch'
    'sdformat',
]

def remove_version(pkg_name: str):
    pkg_name_no_version = re.match('[-_a-z]*', pkg_name)
    if not pkg_name_no_version:
        raise RuntimeError("Could not parse package name")
    return pkg_name_no_version.group(0)

def create_vendor_name(pkg_name: str):
    return f"{pkg_name.replace('-', '_')}_vendor"

def is_gz_library(dep: Dependency):
    pkg_name_no_version = remove_version(dep.name)
    return pkg_name_no_version in GZ_LIBRARIES

def vendorize_gz_dependency(dep: Dependency):
    pkg_name_no_version = remove_version(dep.name)
    dep.name = create_vendor_name(pkg_name_no_version) 

def separate_gz_deps(deps):
    gz_deps = []
    non_gz_deps = []
    for dep in deps:
        if is_gz_library(dep):
            gz_deps.append(dep)
        else:
            non_gz_deps.append(dep)
    return gz_deps, non_gz_deps

def split_version(version: str):
    match = re.match(r'^(\d+)\.(\d+)\.(\d+)$', version)
    if match is None:
        raise ValueError(f'Invalid version string, must be int.int.int: "{version}"')
    new_version = match.groups()
    new_version = [int(x) for x in new_version]
    return {'major': new_version[0], 'minor': new_version[1], 'patch': new_version[2]}

def get_lib_designator(pkg_name: str):
    gz_match = re.match(r'gz-(.*)', pkg_name)
    if gz_match:
        return gz_match.group(1)
    elif pkg_name == 'sdformat':
        return 'sdformat'
    else:
        raise ValueError(f'Could not extract designator from pkg_name: "{pkg_name}"')

def stable_unique(items: list):
    unique_items = []
    for item in items:
        if item not in unique_items:
            unique_items.append(item)
    return unique_items

def create_vendor_package_xml(src_pkg_xml: Package):
    jinja_env = jinja2.Environment(trim_blocks=True, lstrip_blocks=True)
    template = jinja_env.from_string(VENDOR_PKG_XML_TEMPLATE)
    vendor_pkg_xml = copy.deepcopy(src_pkg_xml)

    pkg_name_no_version = remove_version(vendor_pkg_xml.name)
    vendor_name = create_vendor_name(pkg_name_no_version)

    # The gazebo dependencies need to be vendored and we need to use `<depend>`
    # on each dependency regardless of whether it's a build or exec dependency
    gz_build_deps, vendor_pkg_xml.build_depends = separate_gz_deps(vendor_pkg_xml.build_depends)
    gz_exec_deps, vendor_pkg_xml.exec_depends = separate_gz_deps(vendor_pkg_xml.exec_depends)
    gz_test_deps, vendor_pkg_xml.test_depends = separate_gz_deps(vendor_pkg_xml.test_depends)
    gz_doc_deps, vendor_pkg_xml.doc_depends = separate_gz_deps(vendor_pkg_xml.doc_depends)

    gz_deps = stable_unique(gz_build_deps + gz_exec_deps + gz_test_deps + gz_doc_deps)

    for dep in gz_deps:
        vendorize_gz_dependency(dep)

    return template.render(pkg=vendor_pkg_xml, pkg_name_no_version=pkg_name_no_version,
                           vendor_name=vendor_name, gz_vendor_deps=gz_deps)

def create_cmake_file(src_pkg_xml: Package):
    jinja_env = jinja2.Environment(trim_blocks=True, lstrip_blocks=True)
    template = jinja_env.from_string(CMAKES_TEMPLATE)
    vendor_pkg_xml = copy.deepcopy(src_pkg_xml)

    pkg_name_no_version = remove_version(vendor_pkg_xml.name)
    vendor_name = create_vendor_name(pkg_name_no_version)

    # The gazebo dependencies need to be vendored and we need to use `<depend>`
    # on each dependency regardless of whether it's a build or exec dependency
    gz_build_deps, _ = separate_gz_deps(vendor_pkg_xml.build_depends)
    gz_exec_deps, _ = separate_gz_deps(vendor_pkg_xml.exec_depends)
    gz_test_deps, _ = separate_gz_deps(vendor_pkg_xml.test_depends)
    gz_doc_deps, _ = separate_gz_deps(vendor_pkg_xml.doc_depends)

    gz_deps = stable_unique(gz_build_deps + gz_exec_deps + gz_test_deps + gz_doc_deps)

    for dep in gz_deps:
        vendorize_gz_dependency(dep)

    return template.render(pkg=vendor_pkg_xml, pkg_name_no_version=pkg_name_no_version,
                           vendor_name=vendor_name, gz_vendor_deps=gz_deps,
                           lib_designator=get_lib_designator(pkg_name_no_version),
                           version=split_version(vendor_pkg_xml.version))

def main(argv=sys.argv[1:]):
    parser = argparse.ArgumentParser(
        description='Parse package.xml file and generate a vendor package',
    )
    parser.add_argument(
        '--package_xml_output',
        type=str,
        help='The path to a package.xml file',
    )
    parser.add_argument(
        '--cmake_output',
        type=str,
        help='The path to a package.xml file',
    )
    parser.add_argument(
        'input_package_xml',
        type=argparse.FileType('r', encoding='utf-8'),
        help='The path to a package.xml file',
    )
    args = parser.parse_args(argv)
    try:
        package = parse_package_string(
            args.input_package_xml.read(), filename=args.input_package_xml.name)
    except Exception as e:
        print("Error parsing '%s':" % args.input_package_xml.name, file=sys.stderr)
        raise e
    finally:
        args.input_package_xml.close()

    output_package_xml = create_vendor_package_xml(package)
    output_cmake = create_cmake_file(package)
    if args.package_xml_output:
        with open(args.package_xml_output, 'w') as f:
            f.write(output_package_xml)
    else:
        print(output_package_xml)

    if args.cmake_output:
        with open(args.cmake_output, 'w') as f:
            f.write(output_cmake)
    else:
        print(output_cmake)

if __name__ == "__main__":
    main()
